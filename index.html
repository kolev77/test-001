<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Configurator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=Instrument+Serif:ital@0;1&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        solar: {
                            50: '#fffbeb',
                            100: '#fef3c7',
                            200: '#fde68a',
                            300: '#fcd34d',
                            400: '#fbbf24',
                            500: '#f59e0b',
                            600: '#d97706',
                            700: '#b45309',
                            800: '#92400e',
                            900: '#78350f'
                        },
                        slate: {
                            850: '#1a1f2e',
                            950: '#0c0f1a'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --solar-glow: #f59e0b;
            --solar-deep: #d97706;
            --panel-bg: #141821;
            --panel-surface: #1c2030;
            --panel-border: #2a2f40;
            --text-primary: #e8e4dd;
            --text-muted: #8a8690;
            --canvas-bg: #0f1218;
            --accent-green: #34d399;
            --accent-green-muted: rgba(52, 211, 153, 0.15);
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--canvas-bg);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Subtle grid pattern overlay */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(245, 158, 11, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(245, 158, 11, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: 0;
        }

        .app-container { position: relative; z-index: 1; }

        /* Header glow line */
        .header-glow {
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--solar-glow), transparent);
            opacity: 0.6;
        }

        .brand-title {
            font-family: 'Instrument Serif', serif;
            letter-spacing: -0.02em;
        }

        /* Panel styling */
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--text-muted);
            padding-bottom: 0.625rem;
            border-bottom: 1px solid var(--panel-border);
        }

        /* Solar panel config card */
        .panel-solar {
            background: linear-gradient(135deg, #064e3b 0%, #052e16 100%);
            border: 1px solid rgba(52, 211, 153, 0.2);
            position: relative;
            overflow: hidden;
        }
        .panel-solar::before {
            content: '';
            position: absolute;
            top: -40%;
            right: -20%;
            width: 160px;
            height: 160px;
            background: radial-gradient(circle, rgba(52, 211, 153, 0.12) 0%, transparent 70%);
            pointer-events: none;
        }

        /* Range input styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: var(--panel-border);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--solar-glow);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
            transition: box-shadow 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 14px rgba(245, 158, 11, 0.6);
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--solar-glow);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
        }

        .range-tol::-webkit-slider-thumb {
            background: #fb923c;
            box-shadow: 0 0 8px rgba(251, 146, 60, 0.4);
        }
        .range-tol::-webkit-slider-thumb:hover {
            box-shadow: 0 0 14px rgba(251, 146, 60, 0.6);
        }

        /* Number inputs */
        input[type="number"] {
            background: var(--panel-surface);
            border: 1px solid var(--panel-border);
            color: var(--text-primary);
            border-radius: 6px;
            font-family: 'DM Sans', sans-serif;
            transition: border-color 0.2s;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: var(--solar-glow);
            box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.15);
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            opacity: 0.5;
        }

        /* Canvas */
        canvas {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
        }

        /* Stat cards */
        .stat-card {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        .stat-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
        }
        .stat-card.green::after { background: var(--accent-green); }
        .stat-card.purple::after { background: #a78bfa; }
        .stat-card.amber::after { background: var(--solar-glow); }
        .stat-card.orange::after { background: #fb923c; }

        /* Toggle buttons */
        .opt-btn {
            transition: all 0.25s ease;
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
        }
        .opt-btn.active {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(217, 119, 6, 0.15));
            border-color: var(--solar-glow);
            color: #fcd34d;
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.1);
        }
        .opt-btn.inactive {
            background: transparent;
            border-color: var(--panel-border);
            color: var(--text-muted);
        }
        .opt-btn:hover:not(.active) {
            border-color: rgba(245, 158, 11, 0.4);
            color: var(--text-primary);
        }


        /* Export buttons */
        .btn-export {
            background: var(--panel-surface);
            border: 1px solid var(--panel-border);
            color: var(--text-muted);
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s;
            cursor: pointer;
        }
        .btn-export:hover {
            border-color: var(--solar-glow);
            color: var(--solar-glow);
            box-shadow: 0 0 12px rgba(245, 158, 11, 0.1);
        }

        /* Checkbox styling */
        input[type="checkbox"] {
            accent-color: var(--solar-glow);
        }

        /* Fade-in animation */
        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeUp 0.5s ease both;
        }
        .fade-in-d1 { animation-delay: 0.05s; }
        .fade-in-d2 { animation-delay: 0.1s; }
        .fade-in-d3 { animation-delay: 0.15s; }
        .fade-in-d4 { animation-delay: 0.2s; }

        /* Sun icon pulse */
        @keyframes sunPulse {
            0%, 100% { opacity: 0.7; filter: drop-shadow(0 0 6px rgba(251,191,36,0.3)); }
            50% { opacity: 1; filter: drop-shadow(0 0 12px rgba(251,191,36,0.5)); }
        }
        .sun-icon { animation: sunPulse 3s ease-in-out infinite; }

        /* Label styling */
        .param-label {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }
        .param-value {
            color: var(--solar-glow);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .param-value-tol {
            color: #fb923c;
            font-weight: 700;
        }
    </style>
</head>
<body class="p-4 md:p-6 lg:p-8">
    <div class="app-container max-w-7xl mx-auto">

        <!-- Header -->
        <header class="mb-8 fade-in">
            <div class="flex items-center justify-center gap-4 mb-3">
                <svg class="sun-icon w-10 h-10 md:w-12 md:h-12 text-solar-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="4"/>
                    <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
                </svg>
                <h1 class="brand-title text-4xl md:text-5xl lg:text-6xl text-solar-100">Solar System Configurator</h1>
            </div>
            <div class="header-glow mt-4"></div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-5">

            <!-- Left sidebar -->
            <div class="lg:col-span-1 space-y-4">

                <!-- Trapezoid params -->
                <div class="panel p-5 space-y-4 fade-in fade-in-d1">
                    <h2 class="panel-header">Параметри на покрива</h2>

                    <div>
                        <label class="param-label block">Горна основа : <span id="valB" class="param-value">400</span> см</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inputB" min="50" max="1100" value="400" aria-label="Дължина на горната основа в сантиметри" class="flex-1">
                            <input type="number" id="inputBNum" min="50" max="1100" value="400" class="w-16 text-xs px-1.5 py-1 text-center">
                        </div>
                    </div>
                    <div>
                        <label class="param-label block">Долна основа : <span id="valA" class="param-value">500</span> см</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inputA" min="200" max="1200" value="500" aria-label="Дължина на долната основа в сантиметри" class="flex-1">
                            <input type="number" id="inputANum" min="200" max="1200" value="500" class="w-16 text-xs px-1.5 py-1 text-center">
                        </div>
                    </div>
                    <div>
                        <label class="param-label block">Височина : <span id="valH" class="param-value">200</span> см</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inputH" min="50" max="800" value="200" aria-label="Височина на трапеца в сантиметри" class="flex-1">
                            <input type="number" id="inputHNum" min="50" max="800" value="200" class="w-16 text-xs px-1.5 py-1 text-center">
                        </div>
                    </div>

                    <div class="space-y-3 pt-3" style="border-top: 1px solid var(--panel-border);">
                        <p class="text-center" style="font-size:0.6rem; color: var(--text-muted); letter-spacing:0.1em; text-transform:uppercase;">Автоматични бедра</p>
                        <div>
                            <label class="param-label block">Лява страна : <span id="valC" class="param-value">206</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputC" min="50" max="1200" value="206" aria-label="Ляво бедро в сантиметри" class="flex-1">
                                <input type="number" id="inputCNum" min="50" max="1200" value="206" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                        <div>
                            <label class="param-label block">Дясна страна : <span id="valD" class="param-value">206</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputD" min="50" max="1200" value="206" aria-label="Дясно бедро в сантиметри" class="flex-1">
                                <input type="number" id="inputDNum" min="50" max="1200" value="206" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                    </div>

                    <div class="pt-3 space-y-4" style="border-top: 1px solid var(--panel-border);">
                        <div>
                            <label class="param-label block">Толеранс (излизане): <span id="valTol" class="param-value-tol">15</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputTol" min="0" max="50" value="15" aria-label="Допустимо излизане в сантиметри" class="flex-1 range-tol">
                                <input type="number" id="inputTolNum" min="0" max="50" value="15" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                        <div>
                            <label class="param-label block">Отстояние от основа: <span id="valVM" class="param-value-tol">15</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputVM" min="0" max="100" value="15" aria-label="Отстояние от долната основа в сантиметри" class="flex-1 range-tol">
                                <input type="number" id="inputVMNum" min="0" max="100" value="15" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Detail / Panel config -->
                <div class="panel panel-solar p-5 space-y-4 fade-in fade-in-d2" style="color: #d1fae5;">
                    <h2 class="panel-header" style="color: rgba(167,243,208,0.5); border-color: rgba(52,211,153,0.2);">Соларен Панел</h2>
                    <div class="space-y-3 relative z-10">
                        <div>
                            <label class="param-label block" style="color: rgba(167,243,208,0.7);">Ширина : <span id="valRW" class="param-value" style="color: #6ee7b7;">150</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputRW" min="10" max="300" value="150" aria-label="Ширина на панела в сантиметри" class="flex-1">
                                <input type="number" id="inputRWNum" min="10" max="300" value="150" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                        <div>
                            <label class="param-label block" style="color: rgba(167,243,208,0.7);">Височина : <span id="valRH" class="param-value" style="color: #6ee7b7;">75</span> см</label>
                            <div class="flex items-center gap-2">
                                <input type="range" id="inputRH" min="10" max="300" value="75" aria-label="Височина на панела в сантиметри" class="flex-1">
                                <input type="number" id="inputRHNum" min="10" max="300" value="75" class="w-16 text-xs px-1.5 py-1 text-center">
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2 pt-2 relative z-10" style="border-top: 1px solid rgba(52,211,153,0.15);">
                        <input type="checkbox" id="inputRotate" class="w-4 h-4" style="accent-color: #34d399;">
                        <label for="inputRotate" class="text-xs cursor-pointer" style="opacity:0.7;">Авто завъртане 90° (ако побира повече)</label>
                    </div>
                    <div class="pt-3 text-center relative z-10">
                        <div class="text-5xl font-bold tracking-tight" id="resCount" style="color: #6ee7b7; text-shadow: 0 0 30px rgba(52,211,153,0.3);">0</div>
                        <div style="font-size:0.6rem; opacity:0.5; text-transform:uppercase; letter-spacing:0.1em; margin-top:0.375rem;">Брой панели</div>
                    </div>
                </div>
            </div>

            <!-- Main canvas area -->
            <div class="lg:col-span-3 flex flex-col items-center fade-in fade-in-d3">
                <canvas id="trapCanvas" width="800" height="600" class="w-full h-auto"></canvas>

                <div class="mt-3 flex gap-2 justify-end w-full">
                    <button id="exportPNG" class="btn-export px-4 py-2 text-xs">Експорт PNG</button>
                    <button id="exportJSON" class="btn-export px-4 py-2 text-xs">Експорт JSON</button>
                </div>

                <div class="mt-4 grid grid-cols-2 sm:grid-cols-4 gap-3 w-full fade-in fade-in-d4">
                    <div class="stat-card green p-3 text-center">
                        <div style="font-size:0.6rem; text-transform:uppercase; letter-spacing:0.08em; color:var(--text-muted);">Ляво откл.</div>
                        <div class="text-sm font-bold mt-1" style="color: var(--accent-green);"><span id="resOffX">0</span> <span style="font-weight:400; opacity:0.5;">см</span></div>
                    </div>
                    <div class="stat-card purple p-3 text-center">
                        <div style="font-size:0.6rem; text-transform:uppercase; letter-spacing:0.08em; color:var(--text-muted);">Дясно откл.</div>
                        <div class="text-sm font-bold mt-1" style="color: #a78bfa;"><span id="resOffY">0</span> <span style="font-weight:400; opacity:0.5;">см</span></div>
                    </div>
                    <div class="stat-card amber p-3 text-center">
                        <div style="font-size:0.6rem; text-transform:uppercase; letter-spacing:0.08em; color:var(--text-muted);">Площ на покрив</div>
                        <div class="text-sm font-bold mt-1" style="color: var(--solar-glow);"><span id="resArea">0</span> <span style="font-weight:400; opacity:0.5;">м²</span></div>
                    </div>
                    <div class="stat-card orange p-3 text-center">
                        <div style="font-size:0.6rem; text-transform:uppercase; letter-spacing:0.08em; color:var(--text-muted);">Ефективност</div>
                        <div class="text-sm font-bold mt-1" style="color: #fb923c;"><span id="resFillPercent">0%</span></div>
                    </div>
                </div>

                <div class="mt-3" style="font-size:0.625rem; color:var(--text-muted); text-align:center; line-height:1.6;">
                    * Първият ред започва с <span id="footerVM">15</span> см отстояние от долната основа.<br>
                    * Детайлите могат да излизат до <span id="footerTol">15</span> см извън границите на покрива.
                </div>
            </div>

        </div>

        <!-- Footer -->
        <footer class="mt-10 pb-4 text-center" style="font-size:0.6rem; color:var(--text-muted); letter-spacing:0.05em;">
            Solar System Configurator &mdash; Precision Panel Layout Engine
        </footer>
    </div>

    <script>
        const CONFIG = {
            TOLERANCE_CM: 15,
            VERTICAL_MARGIN_CM: 15,
            MIN_BASE_DIFFERENCE: 0,
            MAX_SPIRAL_ITERATIONS: 100,
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 600,
            SCALE_PADDING: 1.3
        };

        const COLORS = {
            TRAPEZOID_FILL: '#1c2030',
            TRAPEZOID_STROKE: '#d97706',
            RECT_FULL: { fill: 'rgba(52, 211, 153, 0.3)', stroke: '#34d399' },
            RECT_TOLERANCE: { fill: 'rgba(251, 191, 36, 0.25)', stroke: '#fbbf24' },
            TOLERANCE_LINE: 'rgba(251, 191, 36, 0.2)'
        };

        const canvas = document.getElementById('trapCanvas');
        const ctx = canvas.getContext('2d');

        const el = {
            a: document.getElementById('inputA'),
            b: document.getElementById('inputB'),
            h: document.getElementById('inputH'),
            c: document.getElementById('inputC'),
            d: document.getElementById('inputD'),
            rw: document.getElementById('inputRW'),
            rh: document.getElementById('inputRH'),
            rwNum: document.getElementById('inputRWNum'),
            rhNum: document.getElementById('inputRHNum'),
            valRW: document.getElementById('valRW'),
            valRH: document.getElementById('valRH'),
            tol: document.getElementById('inputTol'),
            tolNum: document.getElementById('inputTolNum'),
            valTol: document.getElementById('valTol'),
            vm: document.getElementById('inputVM'),
            vmNum: document.getElementById('inputVMNum'),
            valVM: document.getElementById('valVM'),
            aNum: document.getElementById('inputANum'),
            bNum: document.getElementById('inputBNum'),
            hNum: document.getElementById('inputHNum'),
            cNum: document.getElementById('inputCNum'),
            dNum: document.getElementById('inputDNum'),
            valA: document.getElementById('valA'),
            valB: document.getElementById('valB'),
            valH: document.getElementById('valH'),
            valC: document.getElementById('valC'),
            valD: document.getElementById('valD'),
            offX: document.getElementById('resOffX'),
            offY: document.getElementById('resOffY'),
            area: document.getElementById('resArea'),
            count: document.getElementById('resCount'),
            fill: document.getElementById('resFillPercent')
        };

        function validateInput(value, min, max, defaultVal) {
            const num = parseInt(value);
            if (isNaN(num)) return defaultVal;
            return Math.max(min, Math.min(max, num));
        }

        function syncGeometry(source) {
            let a = validateInput(el.a.value, 200, 1200, 500);
            let b = validateInput(el.b.value, 50, 1100, 400);
            let h = validateInput(el.h.value, 50, 800, 200);
            let c = validateInput(el.c.value, 50, 1200, 206);
            let d = validateInput(el.d.value, 50, 1200, 206);

            const diff = Math.abs(a - b);

            if (['a', 'b', 'h', 'init'].includes(source)) {
                const hDiff = diff / 2;
                const s = Math.sqrt(hDiff * hDiff + h * h);
                el.c.value = Math.round(s);
                el.d.value = Math.round(s);
            } else if (source === 'c') {
                const ox = Math.sqrt(Math.max(0, c * c - h * h));
                if (ox > diff) el.c.value = Math.round(Math.sqrt(diff * diff + h * h));
                const oy = diff - Math.min(ox, diff);
                el.d.value = Math.round(Math.sqrt(oy * oy + h * h));
            } else if (source === 'd') {
                const oy = Math.sqrt(Math.max(0, d * d - h * h));
                if (oy > diff) el.d.value = Math.round(Math.sqrt(diff * diff + h * h));
                const ox = diff - Math.min(oy, diff);
                el.c.value = Math.round(Math.sqrt(ox * ox + h * h));
            }
            scheduleRedraw();
        }

        function isPointInPoly(pt, poly) {
            let inside = false;
            for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                const xi = poly[i].x, yi = poly[i].y;
                const xj = poly[j].x, yj = poly[j].y;
                const intersect = ((yi > pt.y) !== (yj > pt.y))
                    && (pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function checkRectFit(rx, ry, rw, rh, poly, maxOutPx) {
            const corners = [
                {x: rx, y: ry},
                {x: rx + rw, y: ry},
                {x: rx, y: ry + rh},
                {x: rx + rw, y: ry + rh}
            ];

            for (let p of corners) {
                if (!isPointInPoly(p, poly)) {
                    let minDist = Infinity;
                    for (let i = 0; i < poly.length; i++) {
                        const p1 = poly[i];
                        const p2 = poly[(i + 1) % poly.length];
                        const d = distToSegment(p, p1, p2);
                        if (d < minDist) minDist = d;
                    }
                    if (minDist > maxOutPx) return "none";
                }
            }

            const midPoints = [
                {x: rx + rw/2, y: ry},
                {x: rx + rw/2, y: ry + rh},
                {x: rx, y: ry + rh/2},
                {x: rx + rw, y: ry + rh/2}
            ];
            for (let p of midPoints) {
                if (!isPointInPoly(p, poly)) {
                    let minDist = Infinity;
                    for (let i = 0; i < poly.length; i++) {
                        const d = distToSegment(p, poly[i], poly[(i + 1) % poly.length]);
                        if (d < minDist) minDist = d;
                    }
                    if (minDist > maxOutPx) return "none";
                }
            }

            const allInside = [...corners, ...midPoints].every(p => isPointInPoly(p, poly));
            return allInside ? "full" : "tol";
        }

        function distToSegment(p, v, w) {
            const l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
            if (l2 === 0) return Math.sqrt(Math.pow(p.x - v.x, 2) + Math.pow(p.y - v.y, 2));
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return Math.sqrt(Math.pow(p.x - proj.x, 2) + Math.pow(p.y - proj.y, 2));
        }

        function draw() {
          try {
            const a = parseInt(el.a.value);
            const b = parseInt(el.b.value);
            const h = parseInt(el.h.value);
            const c = parseInt(el.c.value);
            const d = parseInt(el.d.value);
            const rw = parseInt(el.rw.value);
            const rh = parseInt(el.rh.value);
            const tolCm = parseInt(el.tol.value) || 0;
            const vmCm = parseInt(el.vm.value) || 0;

            el.valA.innerText = a; el.valB.innerText = b; el.valH.innerText = h;
            el.valC.innerText = c; el.valD.innerText = d;
            el.valTol.innerText = tolCm;
            el.tolNum.value = tolCm;
            el.valVM.innerText = vmCm;
            el.vmNum.value = vmCm;
            document.getElementById('footerTol').innerText = tolCm;
            document.getElementById('footerVM').innerText = vmCm;

            el.aNum.value = a; el.bNum.value = b; el.hNum.value = h;
            el.cNum.value = c; el.dNum.value = d;

            const offX = Math.sqrt(Math.max(0, c * c - h * h));
            const offY = Math.sqrt(Math.max(0, d * d - h * h));
            el.offX.innerText = offX.toFixed(1);
            el.offY.innerText = offY.toFixed(1);

            const areaTrap = ((a + b) / 2) * h;
            el.area.innerText = (areaTrap / 10000).toFixed(2);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const maxBase = Math.max(a, b);
            const scale = Math.min(canvas.width / (maxBase * CONFIG.SCALE_PADDING), canvas.height / (h * 1.5));
            const startY = (canvas.height - h * scale) / 2 + h * scale;

            // Center the trapezoid based on the wider base
            let bottomLeft, bottomRight, topLeft, topRight;

            if (a >= b) {
                // Normal trapezoid: bottom wider than top
                const startX = (canvas.width - a * scale) / 2;

                bottomLeft = { x: startX, y: startY };
                bottomRight = { x: startX + a * scale, y: startY };
                topRight = { x: startX + a * scale - offY * scale, y: startY - h * scale };
                topLeft = { x: startX + offX * scale, y: startY - h * scale };
            } else {
                // Inverted trapezoid: top wider than bottom
                const startX = (canvas.width - b * scale) / 2;

                topLeft = { x: startX, y: startY - h * scale };
                topRight = { x: startX + b * scale, y: startY - h * scale };
                bottomRight = { x: startX + b * scale - offY * scale, y: startY };
                bottomLeft = { x: startX + offX * scale, y: startY };
            }

            const poly = [bottomLeft, bottomRight, topRight, topLeft];
            const trapCenterX = (bottomLeft.x + bottomRight.x) / 2;

            // Draw trapezoid
            ctx.beginPath();
            ctx.moveTo(poly[0].x, poly[0].y);
            poly.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.fillStyle = COLORS.TRAPEZOID_FILL;
            ctx.fill();
            ctx.strokeStyle = COLORS.TRAPEZOID_STROKE;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Tolerance margin line
            const sTol = tolCm * scale;
            ctx.beginPath();
            ctx.setLineDash([10, 5]);
            ctx.lineWidth = 1;
            ctx.strokeStyle = COLORS.TOLERANCE_LINE;
            const toleranceY = startY - vmCm * scale;
            ctx.moveTo(0, toleranceY);
            ctx.lineTo(canvas.width, toleranceY);
            ctx.stroke();
            ctx.setLineDash([]);

            const sVM = vmCm * scale;
            const allowRotation = document.getElementById('inputRotate').checked;
            const sRW = rw * scale;
            const sRH = rh * scale;

            function packRow(y, pw, ph) {
                const row = [];
                const cx = trapCenterX - pw / 2;
                const centerFit = checkRectFit(cx, y, pw, ph, poly, sTol);
                if (centerFit !== "none") {
                    row.push({x: cx, y, w: pw, h: ph, fit: centerFit});
                    let offset = 1;
                    while (true) {
                        let addedAny = false;
                        const rightX = cx + offset * pw;
                        const rFit = checkRectFit(rightX, y, pw, ph, poly, sTol);
                        const leftX = cx - offset * pw;
                        const lFit = checkRectFit(leftX, y, pw, ph, poly, sTol);
                        if (rFit !== "none") { row.push({x: rightX, y, w: pw, h: ph, fit: rFit}); addedAny = true; }
                        if (lFit !== "none") { row.push({x: leftX, y, w: pw, h: ph, fit: lFit}); addedAny = true; }
                        if (!addedAny) break;
                        offset++;
                        if (offset > CONFIG.MAX_SPIRAL_ITERATIONS) break;
                    }
                }
                return row;
            }

            const packed = [];
            let cursor = startY - sVM;
            const minY = startY - h * scale;

            if (!allowRotation || rw === rh) {
                while (cursor - sRH >= minY) {
                    const row = packRow(cursor - sRH, sRW, sRH);
                    if (row.length === 0) break;
                    packed.push(...row);
                    cursor -= sRH;
                }
            } else {
                function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
                const chunkCm = (rh * rw) / gcd(rh, rw);
                const chunkPx = chunkCm * scale;
                const nRowsNormal = chunkCm / rh;
                const nRowsRotated = chunkCm / rw;

                while (cursor - Math.min(sRH, sRW) >= minY) {
                    let normalRects = [];
                    for (let i = 0; i < nRowsNormal; i++) {
                        const rowY = cursor - sRH * (i + 1);
                        if (rowY < minY) break;
                        normalRects.push(...packRow(rowY, sRW, sRH));
                    }

                    let rotatedRects = [];
                    for (let i = 0; i < nRowsRotated; i++) {
                        const rowY = cursor - sRW * (i + 1);
                        if (rowY < minY) break;
                        rotatedRects.push(...packRow(rowY, sRH, sRW));
                    }

                    if (normalRects.length === 0 && rotatedRects.length === 0) break;

                    if (rotatedRects.length > normalRects.length) {
                        packed.push(...rotatedRects);
                    } else {
                        packed.push(...normalRects);
                    }
                    cursor -= chunkPx;
                }
            }

            packed.forEach(r => {
                ctx.beginPath();
                ctx.rect(r.x, r.y, r.w, r.h);
                const color = r.fit === "tol" ? COLORS.RECT_TOLERANCE : COLORS.RECT_FULL;
                ctx.fillStyle = color.fill;
                ctx.strokeStyle = color.stroke;
                ctx.fill();
                ctx.stroke();
            });

            el.count.innerText = packed.length;
            el.fill.innerText = (((packed.length * rw * rh) / areaTrap) * 100).toFixed(1) + "%";
          } catch (err) {
            console.error('Draw error:', err);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ef4444';
            ctx.font = '14px sans-serif';
            ctx.fillText('Грешка при изчертаване. Проверете стойностите.', 20, 30);
          }
        }

        let _rafId = null;
        function scheduleRedraw() {
            if (_rafId) return;
            _rafId = requestAnimationFrame(() => {
                _rafId = null;
                draw();
            });
        }

        function syncNumToRange(numEl, rangeEl, source) {
            numEl.addEventListener('input', () => {
                rangeEl.value = numEl.value;
                if (source) syncGeometry(source);
                else scheduleRedraw();
            });
        }

        el.a.addEventListener('input', () => syncGeometry('a'));
        el.b.addEventListener('input', () => syncGeometry('b'));
        el.h.addEventListener('input', () => syncGeometry('h'));
        el.c.addEventListener('input', () => syncGeometry('c'));
        el.d.addEventListener('input', () => syncGeometry('d'));
        el.tol.addEventListener('input', scheduleRedraw);
        el.vm.addEventListener('input', scheduleRedraw);
        syncNumToRange(el.tolNum, el.tol, null);
        syncNumToRange(el.vmNum, el.vm, null);
        syncNumToRange(el.aNum, el.a, 'a');
        syncNumToRange(el.bNum, el.b, 'b');
        syncNumToRange(el.hNum, el.h, 'h');
        syncNumToRange(el.cNum, el.c, 'c');
        syncNumToRange(el.dNum, el.d, 'd');

        // Panel dimension sliders
        function syncPanelDim(slider, numInput, valSpan) {
            slider.addEventListener('input', () => { numInput.value = slider.value; valSpan.innerText = slider.value; scheduleRedraw(); });
            numInput.addEventListener('input', () => {
                let v = Math.max(+numInput.min, Math.min(+numInput.max, +numInput.value || +numInput.min));
                slider.value = v; valSpan.innerText = v; scheduleRedraw();
            });
        }
        syncPanelDim(el.rw, el.rwNum, el.valRW);
        syncPanelDim(el.rh, el.rhNum, el.valRH);
        document.getElementById('inputRotate').addEventListener('change', scheduleRedraw);

        // Export PNG
        document.getElementById('exportPNG').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'solar-layout.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Export JSON
        document.getElementById('exportJSON').addEventListener('click', () => {
            const data = {
                trapezoid: {
                    bottomBase: parseInt(el.a.value),
                    topBase: parseInt(el.b.value),
                    height: parseInt(el.h.value),
                    leftLeg: parseInt(el.c.value),
                    rightLeg: parseInt(el.d.value)
                },
                detail: {
                    width: parseInt(el.rw.value),
                    height: parseInt(el.rh.value)
                },
                results: {
                    count: parseInt(el.count.innerText),
                    efficiency: el.fill.innerText,
                    trapezoidArea: parseFloat(el.area.innerText)
                },
                config: { toleranceCm: parseInt(el.tol.value) || 0, verticalMarginCm: parseInt(el.vm.value) || 0 }
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'solar-measurements.json';
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);
        });

        window.onload = () => {
            syncGeometry('init');
            draw();
        };
    </script>
</body>
</html>
